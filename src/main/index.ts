// Load environment variables from .env in development; ignore if module missing
try {
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  require('dotenv').config();
  // eslint-disable-next-line no-console
  console.log('[ENV] .env loaded');
} catch (e) {
  // eslint-disable-next-line no-console
  console.warn('[ENV] dotenv not found; skipping .env load');
}
import { app, BrowserWindow, session, desktopCapturer, Menu, systemPreferences } from 'electron';
import { registerHandler } from './ipc/handlers';
import { handleImportFile, handleImportFilePaths } from './ipc/import-handler';
import { handleLoadMediaLibrary, handleSaveMediaLibrary } from './ipc/media-library-handler';
import { handleStartExport, handleCancelExport } from './ipc/export-handler';
import { IPC_CHANNELS, SaveMediaLibraryRequest } from '../types/ipc';
import {
  handleGetScreenSources,
  handleSetCaptureSource,
  handleSaveRecordingFile,
  handleTranscodeWebmToMp4,
  getSelectedSourceId,
  handleChooseRecordingOutput,
  handleOpenRecordingsFolder,
} from './ipc/recording-handler';
import { handleGenerateCaptions } from './ipc/transcription-handler';
import { handleReadTextFile } from './ipc/fs-bridge';
import { handleRevealInFolder } from './ipc/shell-bridge';

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Allow file:// pages to load other file:// resources anywhere on disk
// Needed so the renderer can play local videos by absolute path in packaged app
app.commandLine.appendSwitch('allow-file-access-from-files');

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 800,
    width: 1200,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      // Security settings as per PRD Section 6
      contextIsolation: true,     // Isolates preload scripts from renderer
      nodeIntegration: false,      // Prevents Node.js APIs in renderer (security best practice)
      // NOTE: sandbox is disabled due to webpack asset-relocator-loader __dirname issue
      // contextIsolation + nodeIntegration:false still provides strong security
      sandbox: false,
      // LAX for local app: allow file:// resources in dev and packaged
      webSecurity: false,
      allowRunningInsecureContent: true,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // DevTools can be toggled via keyboard shortcut (CmdOrCtrl+Alt+I or F12)
  // No longer auto-opened to avoid distracting users
  
  // Setup application menu with DevTools toggle
  const template: Electron.MenuItemConstructorOptions[] = [
    {
      label: 'View',
      submenu: [
        {
          label: 'Toggle Developer Tools',
          accelerator: process.platform === 'darwin' ? 'Alt+Command+I' : 'Ctrl+Shift+I',
          click: () => {
            mainWindow.webContents.toggleDevTools();
          }
        },
        {
          label: 'Toggle DevTools (F12)',
          accelerator: 'F12',
          click: () => {
            mainWindow.webContents.toggleDevTools();
          },
          visible: false, // hidden menu item, just for the keyboard shortcut
        }
      ]
    }
  ];
  
  const menu = Menu.buildFromTemplate(template);
  Menu.setApplicationMenu(menu);
};

/**
 * Register all IPC handlers
 * 
 * WHY THIS IS HERE:
 * - Handlers must be registered before any window tries to use them
 * - Centralizes handler registration in one place
 * - Makes it easy to see all available IPC channels
 */
function registerIPCHandlers(): void {
  // Register the import file handler (file picker dialog)
  registerHandler(IPC_CHANNELS.IMPORT_FILE, handleImportFile);
  // Register drag-and-drop paths import handler
  registerHandler(IPC_CHANNELS.IMPORT_FILE_PATHS, async (event, ...args) => {
    const req = (args?.[0] ?? {}) as { paths?: string[] };
    return handleImportFilePaths(event, { paths: Array.isArray(req.paths) ? req.paths : [] });
  });
  
  // Media library persistence handlers
  // Adapt strongly-typed handler to generic IPCHandler signature
  registerHandler(IPC_CHANNELS.SAVE_MEDIA_LIBRARY, async (event, ...args) => {
    const request = (args?.[0] ?? {}) as SaveMediaLibraryRequest;
    return handleSaveMediaLibrary(event, request);
  });
  registerHandler(IPC_CHANNELS.LOAD_MEDIA_LIBRARY, handleLoadMediaLibrary);
  
  // Future handlers will be registered here:
  // registerHandler(IPC_CHANNELS.START_RECORDING, handleStartRecording);
  // etc.
  // Export handler (Epic 5.1)
  registerHandler(IPC_CHANNELS.START_EXPORT, async (event, ...args) => {
    const req = (args?.[0] ?? {}) as unknown;
    return handleStartExport(event, req);
  });
  registerHandler(IPC_CHANNELS.CANCEL_EXPORT, async () => {
    return handleCancelExport();
  });
  
  // Screen recording (Epic 7.1)
  registerHandler(IPC_CHANNELS.GET_SCREEN_SOURCES, async (_event, ...args) => {
    const req = (args?.[0] ?? {}) as { includeWindows?: boolean };
    return handleGetScreenSources(_event, { includeWindows: !!req.includeWindows });
  });
  registerHandler(IPC_CHANNELS.SET_CAPTURE_SOURCE, async (_event, ...args) => {
    const req = (args?.[0] ?? {}) as { sourceId?: string };
    return handleSetCaptureSource(_event, { sourceId: String(req.sourceId ?? '') });
  });
  registerHandler(IPC_CHANNELS.SAVE_RECORDING_FILE, async (_event, ...args) => {
    const req = (args?.[0] ?? {}) as unknown;
    return handleSaveRecordingFile(_event, req as { data: ArrayBuffer; filenameHint?: string });
  });
  registerHandler(IPC_CHANNELS.TRANSCODE_WEBM_TO_MP4, async (_event, ...args) => {
    const req = (args?.[0] ?? {}) as { inputPath?: string; outputPath?: string };
    return handleTranscodeWebmToMp4(_event, { inputPath: String(req.inputPath ?? ''), outputPath: req.outputPath ? String(req.outputPath) : undefined });
  });
  registerHandler(IPC_CHANNELS.CHOOSE_RECORDING_OUTPUT, handleChooseRecordingOutput);
  registerHandler(IPC_CHANNELS.OPEN_RECORDINGS_FOLDER, async () => handleOpenRecordingsFolder());

  // Captions generation (Epic 7.6)
  registerHandler(IPC_CHANNELS.GENERATE_CAPTIONS, async (_event, ...args) => {
    const req = (args?.[0] ?? {}) as { clipId?: string; videoPath?: string };
    return handleGenerateCaptions(_event, { clipId: String(req.clipId ?? ''), videoPath: String(req.videoPath ?? '') });
  });

  // FS Bridge: Read text file (used for loading SRT in renderer)
  registerHandler(IPC_CHANNELS.READ_TEXT_FILE, async (_event, ...args) => {
    const req = (args?.[0] ?? {}) as { path?: string; encoding?: string };
    return handleReadTextFile(_event, { path: String(req.path ?? ''), encoding: (req.encoding as BufferEncoding) || 'utf8' });
  });

  // Shell Bridge: Reveal exported file in folder
  registerHandler(IPC_CHANNELS.REVEAL_IN_FOLDER, async (_event, ...args) => {
    const req = (args?.[0] ?? {}) as { path?: string };
    return handleRevealInFolder(_event, { path: String(req.path ?? '') });
  });
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', async () => {
  // Register IPC handlers BEFORE creating the window
  // This ensures handlers are ready when the renderer loads
  registerIPCHandlers();
  
  // On macOS, explicitly trigger OS camera/microphone prompts if not yet decided
  if (process.platform === 'darwin') {
    try {
      const cam = systemPreferences.getMediaAccessStatus('camera');
      if (cam === 'not-determined') {
        await systemPreferences.askForMediaAccess('camera');
      }
      const mic = systemPreferences.getMediaAccessStatus('microphone');
      if (mic === 'not-determined') {
        await systemPreferences.askForMediaAccess('microphone');
      }
    } catch (e) {
      // eslint-disable-next-line no-console
      console.warn('[PERMISSIONS] Failed to ask for media access', e);
    }
  }

  // Allow media and display-capture permission requests for this app
  session.defaultSession.setPermissionRequestHandler((_wc, permission, callback) => {
    if (permission === 'media' || permission === 'display-capture') {
      callback(true);
    } else {
      callback(false);
    }
  });
  
  // Configure display media request handler for getDisplayMedia (Epic 7.1)
  // Grants access to the user-selected desktopCapturer source
  session.defaultSession.setDisplayMediaRequestHandler(async (request, callback) => {
    try {
      const targetId = getSelectedSourceId();
      if (!targetId) {
        console.warn('[SCREEN] No selected source set; denying request');
        callback({});
        return;
      }
      const sources = await desktopCapturer.getSources({ types: ['screen', 'window'] });
      const match = sources.find((s) => s.id === targetId);
      if (!match) {
        console.warn('[SCREEN] Selected source not found; denying request');
        callback({});
        return;
      }
      const streams: Record<string, unknown> = { video: match };
      // On Windows, allow loopback system audio when requested
      if (process.platform === 'win32' && request.audioRequested) {
        (streams as { audio?: string }).audio = 'loopback';
      }
      callback(streams);
    } catch (e) {
      console.error('[SCREEN] Error handling display media request:', e);
      callback({});
    }
  }, { useSystemPicker: false });
  
  // Now create the window
  createWindow();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
